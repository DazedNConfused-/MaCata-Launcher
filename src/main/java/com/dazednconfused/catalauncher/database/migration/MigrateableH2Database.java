package com.dazednconfused.catalauncher.database.migration;

import com.dazednconfused.catalauncher.database.DAOException;
import com.dazednconfused.catalauncher.database.H2Database;
import com.dazednconfused.catalauncher.helper.result.Result;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.io.FilenameUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Abstract {@link H2Database} implementation for DAOs that allow migrations to be applied on them.
 * */
public abstract class MigrateableH2Database extends H2Database {

    public static final String DATABASE_MIGRATIONS_DEFAULT_RESOURCE_ROOT_PATH = "db/migrations/";

    private static final Logger LOGGER = LoggerFactory.getLogger(MigrateableH2Database.class);

    public static final String MIGRATION_TABLE_NAME = "migration";

    /**
     * Constructor.
     * */
    public MigrateableH2Database() {
        this.initMigrationTable();
        this.applyAllPendingMigrations();
    }

    /**
     * Searches for and applies all pending migrations to this DAO's database.
     * */
    public void applyAllPendingMigrations() throws DAOException {
        LOGGER.debug("Applying all pending migrations...");

        String latestAppliedMigration = this.getLatestAppliedMigration().orElse(null);

        List<String> pendingMigrations;
        if (latestAppliedMigration == null) {
            LOGGER.debug("No migrations have been applied yet for database [{}]. Initializing...", this.getDatabaseName());
            pendingMigrations = this.getDatabaseMigrationFilesDatedAfter(new Date(0));
        } else {
            LOGGER.debug("Latest applied migration: [{}]...", latestAppliedMigration);
            pendingMigrations = this.getDatabaseMigrationFilesDatedAfter(parseYyyyMmDdDate(latestAppliedMigration).orElseThrow());
        }

        LOGGER.debug("Migrations pending: [{}]", pendingMigrations.size());
        pendingMigrations.forEach(migration -> LOGGER.trace("   * [{}]", migration));
        pendingMigrations.forEach(this::applyMigration);

        LOGGER.debug("Finished applying all pending migrations.");
    }

    /**
     * Applies an individual {@code migration} to this DAO's database.
     * */
    public void applyMigration(String migration) throws DAOException {
        LOGGER.debug("Applying migration [{}]...", migration);

        this.executeSqlResource(Paths.get(this.getDatabaseMigrationsResourcePath(), migration).toString());
        this.registerMigration(migration);

        LOGGER.debug("Finished applying migration [{}].", migration);
    }

    /**
     * Registers the supplied {@code migration} to this DAO's database.
     *
     * @apiNote This only <i>registers</i> the given {@code migration} (aka it saves its name as the latest applied migration).
     *          This does <b>not</b> apply said {@code migration}. For that purpose, use {@link #applyMigration(String)} instead.
     * */
    private void registerMigration(String migration) {
        LOGGER.trace("Registering migration [{}]...", migration);

        Optional<Date> dateFromMigration = this.getDateFromFilename(migration);

        if (dateFromMigration.isEmpty()) {
            LOGGER.error("Invalid migration [{}] supplied (does it have a yyyyMMdd date in its name?). Aborting operation.", migration);
            return;
        }

        this.resetMigrations();
        this.insertMigration(migration);

        LOGGER.trace("Migration [{}] registered successfully.", migration);
    }

    /**
     * Initializes the migration tracking table.
     * */
    private void initMigrationTable() throws DAOException {
        LOGGER.trace("Initializing migration table...");

        String sql = "CREATE TABLE IF NOT EXISTS " + MIGRATION_TABLE_NAME + " (" +
            "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " +
            "latest_applied_migration_yyyymmdd TEXT NOT NULL " +
            ")";

        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.execute();
        } catch (SQLException e) {
            LOGGER.error("An error occurred while crafting table creation statement for [{}]", MIGRATION_TABLE_NAME, e);
            throw new DAOException(e);
        }

        LOGGER.trace("Finished initializing migration table.");
    }

    /**
     * Returns the latest SQL migration applied to this DAO's database.
     * */
    protected Optional<String> getLatestAppliedMigration() {
        LOGGER.trace("Retrieving latest applied migration for database [{}]...", this.getDatabaseName());

        String sql = "SELECT TOP 1 * FROM " + MIGRATION_TABLE_NAME;
        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            ResultSet rs = pstmt.executeQuery();

            if (rs.next()) {
                return Optional.of(rs.getString("latest_applied_migration_yyyymmdd"));
            }

            return Optional.empty();
        } catch (SQLException e) {
            LOGGER.error("Failed to retrieve latest applied migration for database [{}]", this.getDatabaseName(), e);
            throw new DAOException(e);
        }
    }

    /**
     * Registers a new applied migration to this DAO's database.
     * */
    private void insertMigration(String migration) throws DAOException {
        LOGGER.trace("Inserting migration [{}] for database [{}]...", migration, this.getDatabaseName());

        String sql = "INSERT INTO " + MIGRATION_TABLE_NAME + "" +
            "(latest_applied_migration_yyyymmdd) " +
            "VALUES " +
            "(?)";

        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, migration);

            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error("An error occurred while inserting migration [{}] for database [{}]", migration, this.getDatabaseName(), e);
            throw new DAOException(e);
        }
    }

    /**
     * Erases all registered migration(s) to this DAO's database.
     * */
    private void resetMigrations() throws DAOException {
        LOGGER.trace("Deleting migration record(s) for for database [{}]...", this.getDatabaseName());

        String sql = "DELETE FROM " + MIGRATION_TABLE_NAME;

        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {

            pstmt.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error("An error occurred while deleting migration record(s) for database [{}]", this.getDatabaseName(), e);
            throw new DAOException(e);
        }
    }

    /**
     * Executes the SQL script residing in the given {@code resourcePath}.
     *
     * @param resourcePath the path to the SQL script resource.
     *
     * @return The SQL's {@link PreparedStatement#execute(String)}'s response, wrapped inside a {@link Result#success(Object)}.
     *         {@link Result#failure(Throwable)} if an error occurred during the operation.
     */
    protected Result<Throwable, Boolean> executeSqlResource(String resourcePath) {
        try (
            var c = getConnection();
            var in = this.getResourceAsStream(resourcePath);
            var isr = new InputStreamReader(in);
            var br = new BufferedReader(isr)
        ) {
            LOGGER.trace("Executing SQL resource [{}]...", resourcePath);

            var sql = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                sql.append(line);
                sql.append("\n");
            }

            LOGGER.trace("SQL resource [{}] to be executed: \n ********** \n {} \n **********", resourcePath, sql);

            try (var pstmt = c.prepareStatement(sql.toString())) {
                boolean result = pstmt.execute();
                LOGGER.trace("Executed SQL resource [{}]", resourcePath);

                return Result.success(result);
            }
        } catch (SQLException | IOException e) {
            LOGGER.error("There was an error while executing SQL resource [{}]", resourcePath, e);
            return Result.failure(e);
        }
    }

    /**
     * Returns all {@code .sql} migrations files that are dated after the provided {@code from} {@link Date}.
     *
     * @implNote All migration files returned by this method are guaranteed to have a correctly-formatted name and be in order
     *           from oldest to newest.
     */
    protected List<String> getDatabaseMigrationFilesDatedAfter(Date from) {
        LOGGER.trace("Retrieving all database migration files dated after [{}]...", from);

        return Optional
            .of(getDatabaseMigrationFiles())
            .map(result -> result.toEither().get().getResult().orElse(Collections.emptyList()))
            .orElse(Collections.emptyList())
            .stream()
            .filter(filename -> FilenameUtils.getExtension(filename).equalsIgnoreCase("sql")) // retrieve only .sql script files
            .filter(filename -> {
                Optional<Date> migrationDateStamp = getDateFromFilename(filename);
                if (migrationDateStamp.isEmpty()) {
                    // without a valid migration Date stamp, we don't know whether we have to apply the migration or not. Better to skip it entirely....
                    LOGGER.trace("Skipping file [{}] for not having a valid migration Date stamp...", filename);
                    return false;
                }

                return migrationDateStamp.get().after(from);
            }) // retrieve only those that were created after the supplied date
            .sorted((fn1, fn2) -> {
                Date d1 = getDateFromFilename(fn1).orElseThrow();
                Date d2 = getDateFromFilename(fn2).orElseThrow();

                return d1.compareTo(d2);
            }) // sort the migrations according to its natural order (aka by their timestamps)
            .collect(Collectors.toList());
    }

    /**
     * List all filenames living inside the classpath's {@link #getDatabaseMigrationsResourcePath()}'s {@code resources} folder.
     *
     * @implNote Migration files returned by this method are <b>not</b> guaranteed to neither have a correctly-formatted name
     *           nor be in order. If you need such assurances, use {@link #getDatabaseMigrationFilesDatedAfter(Date)} passing
     *           {@code new Date(0)} as argument instead.
     */
    protected Result<Throwable, List<String>> getDatabaseMigrationFiles() {
        List<String> filenames = new ArrayList<>();

        try (InputStream in = this.getResourceAsStream(this.getDatabaseMigrationsResourcePath()); BufferedReader br = new BufferedReader(new InputStreamReader(in))) {
            String resource;

            while ((resource = br.readLine()) != null) {
                filenames.add(resource);
            }
        } catch (IOException e) {
            LOGGER.error("There was an error while reading resource files from path [{}]", getDatabaseMigrationsResourcePath());
            return Result.failure(e);
        }

        return Result.success(filenames);
    }

    /**
     * Returns the {@code yyyyMMdd} {@link Date} stamp present in the given {@code filename}, if present.
     */
    private Optional<Date> getDateFromFilename(String filename) {
        Matcher matcher = Pattern.compile("(.*([-_])?)(\\d{8})(.*)").matcher(filename);

        if (!matcher.matches()) {
            // if pattern is invalid, return immediately...
            return Optional.empty();
        } else {
            // yyyyMMdd stamp is always captured in RegExp's Group 3
            return parseYyyyMmDdDate(matcher.group(3));
        }
    }

    /**
     * Reads a specific {@code resource} from the classpath.
     *
     * @implNote It's up to this method's callers to properly close the resulting {@link InputStream}.
     */
    private InputStream getResourceAsStream(String resource) {
        InputStream in = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);
        return in == null ? H2Database.class.getResourceAsStream(resource) : in;
    }

    /**
     * Parses the provided {@code date} in {@code yyyyMMdd} format.
     */
    private static Optional<Date> parseYyyyMmDdDate(String date) {
        try {
            return Optional.of(new SimpleDateFormat("yyyyMMdd").parse(date));
        } catch (Exception e) {
            LOGGER.error("An error has occurred while parsing date [{}] into yyyyMMdd format", date, e);
            return Optional.empty();
        }
    }

    /**
     * Returns the classpath's resource's path associated to the migrations' folder for this DAO's database.
     * */
    public abstract String getDatabaseMigrationsResourcePath();
}