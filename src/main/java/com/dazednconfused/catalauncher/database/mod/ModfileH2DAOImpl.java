package com.dazednconfused.catalauncher.database.mod;

import com.dazednconfused.catalauncher.database.DAOException;
import com.dazednconfused.catalauncher.database.H2Database;
import com.dazednconfused.catalauncher.database.mod.entity.ModfileEntity;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ModfileH2DAOImpl extends H2Database implements ModfileDAO {

    private static final Logger LOGGER = LoggerFactory.getLogger(ModfileH2DAOImpl.class);

    @Override
    public String getDatabaseName() {
        return DATABASE_FILE;
    }

    /**
     * Initializes the {@link #TABLE_NAME} table.
     * */
    @Override
    public Map.Entry<Connection, PreparedStatement> getTableCreationStatement() throws DAOException {
        try {
            String sql = "CREATE TABLE IF NOT EXISTS " + TABLE_NAME + " (" +
                "id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "path TEXT NOT NULL," +
                "hash TEXT NOT NULL," +
                "created_date DATETIME NOT NULL," +
                "updated_date DATETIME NOT NULL" +
                ")";

            Connection conn = this.getConnection();
            return Map.entry(conn, conn.prepareStatement(sql));
        } catch (SQLException e) {
            LOGGER.error("An error occurred while crafting table creation statement for [{}]", TABLE_NAME, e);
            throw new DAOException(e);
        }
    }

    /*
    * The reason why this override exists (as opposed to have the table fully initialized, FKs and all, in the original creation
    * statement), is because this allows this DAO to exist and be tested on its own without dependencies. Otherwise, we wouldn't
    * be able to properly cover this DAO, instead relying on covering the encompassing Repository.
    * */
    @Override
    public void initializeTable() throws DAOException {
        ModfileDAO.super.initializeTable();

        if (this.doesTableExist(ModDAO.TABLE_NAME)) {
            LOGGER.debug("Table [{}] detected. Linking...", ModDAO.TABLE_NAME);

            final String modFKColumnName = "mod_id";
            final String modToModfileFKName = "mod_modfile_fk1";

            String addColumnSQL = "ALTER TABLE " + TABLE_NAME + " ADD COLUMN " + modFKColumnName + " LONG NOT NULL";
            String addForeignKeySQL = "ALTER TABLE " + TABLE_NAME + " ADD CONSTRAINT " + modToModfileFKName + " FOREIGN KEY (" + modFKColumnName + ") REFERENCES " + ModDAO.TABLE_NAME + "(id)";

            try (Connection conn = this.getConnection(); Statement stmt = conn.createStatement()) {
                stmt.execute(addColumnSQL);
                LOGGER.debug("Column [{}] added to table [{}]", modFKColumnName, TABLE_NAME);

                stmt.execute(addForeignKeySQL);
                LOGGER.debug("Foreign key constraint [{}] pointing to table [{}]'s field [id] added to column [{}]", modToModfileFKName, ModDAO.TABLE_NAME, modFKColumnName);
            } catch (SQLException e) {
                LOGGER.error("An error occurred while linking [{}] to [{}]", TABLE_NAME, ModDAO.TABLE_NAME, e);
                throw new DAOException(e);
            }
        }
    }

    @Override
    public ModfileEntity insert(ModfileEntity entity) throws DAOException {
        LOGGER.debug("Inserting ModfileEntity [{}]...", entity);

        String sql = "INSERT INTO " + TABLE_NAME + "" +
            "(path, hash, created_date, updated_date) " +
            "VALUES " +
            "(?, ?, CURRENT_TIMESTAMP(), CURRENT_TIMESTAMP())";

        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, entity.getPath());
            pstmt.setString(2, entity.getHash());

            pstmt.executeUpdate();

            return this.getLatestGeneratedId(pstmt).map(this::findById).orElseThrow(DAOException::new).orElseThrow(DAOException::new);
        } catch (SQLException e) {
            LOGGER.error("An error occurred while inserting entity [{}]", entity, e);
            throw new DAOException(e);
        }
    }

    @Override
    public ModfileEntity update(ModfileEntity entity) throws DAOException {
        Optional<ModfileEntity> originalEntity = this.findById(entity.getId());

        if (originalEntity.isEmpty()) {
            throw new DAOException("No entity with id [" + entity.getId() + "] found");
        }

        LOGGER.debug("Updating ModfileEntity from [{}] to [{}]...", originalEntity.get(), entity);

        String sql = "UPDATE " + TABLE_NAME + " SET " +
            "path = ?, " +
            "hash = ?, " +
            "updated_date = CURRENT_TIMESTAMP() " +
            "WHERE id = ?";

        try (Connection conn = this.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, entity.getPath());
            pstmt.setString(2, entity.getHash());
            pstmt.setLong(3, entity.getId());

            pstmt.executeUpdate();

            return this.findById(entity.getId()).orElseThrow(DAOException::new);
        } catch (SQLException e) {
            LOGGER.error("An error occurred while updating entity [{}]", entity, e);
            throw new DAOException(e);
        }
    }

    @Override
    public ModfileEntity buildFromResultSet(ResultSet rs) throws DAOException {
        LOGGER.trace("Building ModfileEntity from ResultSet [{}]...", rs);

        try {
            return ModfileEntity.builder()
                .id(rs.getLong("id"))
                .path(rs.getString("path"))
                .hash(rs.getString("hash"))
                .createdDate(rs.getTimestamp("created_date"))
                .updatedDate(rs.getTimestamp("updated_date"))
                .build();
        } catch (SQLException e) {
            LOGGER.error("An error occurred while building entity from ResultSet [{}]", rs, e);
            throw new DAOException(e);
        }
    }
}